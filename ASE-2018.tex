%% bare_conf.tex
%% V1.4b
%% 2015/08/26
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.8b or later) with an IEEE
%% conference paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/pkg/ieeetran
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall the IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%*************************************************************************


% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX framework ***
% *** with production work. The IEEE's font choices and paper sizes can   ***
% *** trigger bugs that do not appear when using other class files.       ***                          ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/


\label{beginning of document}
\documentclass[10pt,conference]{IEEEtran}
% Some Computer Society conferences also require the compsoc mode option,
% but others use the standard conference format.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[conference]{../sty/IEEEtran}

\usepackage{makecell}
\usepackage[noadjust]{cite}
\usepackage{graphicx}
\graphicspath{{images/}} 
\renewcommand\IEEEkeywordsname{Keywords}
\usepackage{hyperref}
\hypersetup{colorlinks=true,allcolors=blue}
\usepackage{hypcap}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\lstset{
basicstyle=\ttfamily\scriptsize,
%frame=single,
breaklines=true,
numbers=left,
xleftmargin=2.5em,
framexleftmargin=0em,
emph={
class, extends, operation, abstract,
context, constraint, check,
for, if, return, true, and, ref,
message, in, package, val, attr, 
@link, @node, @compartment,
@namespace, @diagram
},
emphstyle=\textbf
}
\lstdefinestyle{interfaces}{
float=t
}
\lstdefinestyle{xmi}{
basicstyle=\ttfamily\scriptsize,
emph={
X, A, B, C, Class, Package    
}
}
\lstdefinestyle{eol}{
basicstyle=\ttfamily\scriptsize,
emph={
var, new, for, in, create, set, of, with, 
unset, to, add, remove, delete, register, move,
from, position, from, move-within, session, \.
}
}

\lstdefinestyle{java}{
basicstyle=\ttfamily\scriptsize,
emph={
case, $unset$,
instanceof, else, if, void,
new, UnsetEAttributeEvent,
UnsetEReferenceEvent,
@override, public, class, extends
}
}

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}
\newcommand{\dk}[1]{\textbf{[Dimitris: #1]}}

\begin{document}
%
% paper title
% Titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{Towards Hybrid Model Persistence}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations\ref{abstract}


\author{[Hidden for Blind Review]}

%\author{\IEEEauthorblockN{Alfa Yohannis\IEEEauthorrefmark{1}, Horacio Hoyos Rodriguez\IEEEauthorrefmark{2}, Fiona Polack\IEEEauthorrefmark{3}, Dimitris Kolovos\IEEEauthorrefmark{4}}
%\IEEEauthorblockA{
%\IEEEauthorrefmark{1}\IEEEauthorrefmark{2}\IEEEauthorrefmark{4}Department of Computer Science, University of York, United Kingdom \\
%\IEEEauthorrefmark{3}School of Computing and Maths, Keele University, United Kingdom \\
%Email: \IEEEauthorrefmark{1}ary506@york.ac.uk, \IEEEauthorrefmark{2}horacio\_hoyos\_rodriguez@ieee.org, \\
%\IEEEauthorrefmark{3}f.a.c.polack@keele.ac.uk, \IEEEauthorrefmark{4}dimitris.kolovos@york.ac.uk}}



% conference papers do not typically use \thanks and this command
% is locked out in conference mode. If really needed, such as for
% the acknowledgment of grants, issue a \IEEEoverridecommandlockouts
% after \documentclass

% for over three affiliations, or if they all won't fit within the width
% of the page, use this alternative format:
% 
%\author{\IEEEauthorblockN{Michael Shell\IEEEauthorrefmark{1},
%Homer Simpson\IEEEauthorrefmark{2},
%James Kirk\IEEEauthorrefmark{3}, 
%Montgomery Scott\IEEEauthorrefmark{3} and
%Eldon Tyrell\IEEEauthorrefmark{4}}
%\IEEEauthorblockA{\IEEEauthorrefmark{1}School of Electrical and Computer Engineering\\
%Georgia Institute of Technology,
%Atlanta, Georgia 30332--0250\\ Email: see http://www.michaelshell.org/contact.html}
%\IEEEauthorblockA{\IEEEauthorrefmark{2}Twentieth Century Fox, Springfield, USA\\
%Email: homer@thesimpsons.com}
%\IEEEauthorblockA{\IEEEauthorrefmark{3}Starfleet Academy, San Francisco, California 96678-2391\\
%Telephone: (800) 555--1212, Fax: (888) 555--1212}
%\IEEEauthorblockA{\IEEEauthorrefmark{4}Tyrell Inc., 123 Replicant Street, Los Angeles, California 90210--4321}}




% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}




% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
\begin{abstract}
\label{abstract}
In contrast to state-based model persistence approaches (e.g. XMI, NeoEMF) that store snapshots of the state of a model conforming to a 3-level metamodelling architecture such as EMF, change-based approaches persist its complete -- and ever-growing -- editing history instead. Change-based persistence has the potential to support faster and more accurate model comparison, merging, as well as a range of analytics activities. On the other hand, reconstructing the state of a model by replaying its editing history every time the model needs to be queried or modified can get increasingly expensive as the model grows in size. In this work, we integrate change-based and state-based persistence mechanisms in a hybrid model persistence approach that delivers the best of both worlds. In this  paper, we present the design of our hybrid model persistence approach and report on its impact on time and memory footprint for model loading and saving, storage space usage, and model differencing.
\end{abstract}
%
% no keywords
\begin{IEEEkeywords} 
model persistence, hybrid model persistence, change-based model persistence, state-based model persistence, model comparison
\end{IEEEkeywords}

% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle

\vspace{-5pt}
\section{Introduction}
\label{sec:introduction}


Change-based persistence (CBP) of models \cite{DBLP:conf/models/YohannisKP17} conforming to metamodelling architectures such as MOF/EMF \cite{omg2018mof,steinberg2008emf} comes with notable advantages over state-based persistence (SBP): it provides support for fast comparison and differencing of versions of the same model \cite{DBLP:conf/sde/LippeO92,DBLP:conf/caise/IgnatN05,DBLP:conf/edoc/KoegelHLHD10,koegel2010emfstore}  -- which can also substantially speed up incremental model management activities, and enables novel model analytics activities (e.g. pattern detection in the editing history to understand how modellers use modelling languages and tools) \cite{DBLP:journals/entcs/RobbesL07}. However, CBP comes at the cost of ever-growing model files \cite{DBLP:conf/edoc/KoegelHLHD10,DBLP:journals/entcs/RobbesL07} since all changes (even deleting model elements) are recorded in an ever-growing editing log, which naturally leads to longer loading times \cite{mens2002state}. In this work we address the latter challenge by introducing the concept of hybrid persistence of models. In hybrid persistence (HP) the change-based representation is augmented with a  state-based representation (which may be derived from the change-based representation) of the latest state of the model which is used to speed up model loading and querying.

The paper is structured as follows. Section \ref{sec:change_and_state_based_model_persistence} introduces the concept of change-based model persistence and recent work on state-based model persistence. Sections \ref{sec:hybrid_model_persistence} and \ref{sec:implementation} presents our approach to hybrid model persistence and its implementation. Section \ref{sec:evaluation} presents experimental results and evaluation. Section \ref{sec:related_work} provides an overview of related work, and Section \ref{sec:conlcusions_and_future_work} concludes with a discussion on directions for future work.

\section{Change and State-based Model Persistence}
\label{sec:change_and_state_based_model_persistence}
To explain the differences, benefits and drawbacks of CBP and SBP, consider a modelling activity on a UML model as presented Fig. \ref{fig:illustration_cbp}. The sub-figures $a$ to $h$ depict the evolution of a UML model at different time stamps. Classes are created and added/removed from \texttt{Package X}. %"Adding a class involves creating the new class and then settings its name." Not really relevant here... comes in at the end of the next para 

%*** I've changed Lst. and List. to Listing -- it's more readable and now consistent!   F.
In SBP only the final state of the model is persisted. Thus, to represent the final state of the UML model, only the information about \texttt{Package X} and \texttt{Class C} needs to be persisted, as presented in Listing \ref{lst:xmimodel2} (XMI format). In CBP all the changes in the model are persisted. Thus, a list of all the events generated by the model editor is needed to represent the final state of the model.
%", as presented in Listing \ref{lst:cbpmodel}\footnote{We use a natural language pseudo-code of the CBP format introduced in \cite{DBLP:conf/models/YohannisKP17,yohannis2018towards}}.  "  This fits better where you talk about Listing 2...
A session depicts a set of changes made between save events, i.e. a session comprises all the changes that happened since the last time that the model was persisted. The CBP representation is shown in Listing \ref{lst:cbpmodel}\footnote{We use a natural language pseudo-code for CBP, introduced in \cite{DBLP:conf/models/YohannisKP17,yohannis2018towards}}. Lines 2-3 represent the initial state (Fig. \ref{fig:illustration_1}), followed by lines 4-5 (Fig. \ref{fig:illustration_2}), 6-7 (Fig. \ref{fig:illustration_3}), 8 (Fig. \ref{fig:illustration_4}), 9 (Fig. \ref{fig:illustration_5}), 11 (Fig. \ref{fig:illustration_6}), 12 (Fig. \ref{fig:illustration_7}), and 13 (Fig. \ref{fig:illustration_1}). 


%we use two successive versions of a UML2 \cite{eclipse2017uml2} model persisted in the state-based XMI format: the first one is the initial version (Listing \ref{lst:xmimodel1}), and the second one is the update version (Fig. \ref{lst:xmimodel2}). To construct the first version of the model, a package is created and its name is set to ``X''. Two classes also created and their names are set to ``A'' and ``B''. Both classes are then added to the package. The model is then saved and produces a state-based model as presented in Listing \ref{lst:xmimodel1}. In the second session, the model is modified by renaming the class `B'' to ``C'' and removing the class ``A'' from its package and deleting it entirely from the model. After that, the model is saved again to produce the second version of the model as presented in Listing \ref{lst:xmimodel2}. The visual illustration of these series of modification is depicted in Fig. \ref{fig:illustration_cbp}.

%\begin{lstlisting}[style=xmi,caption={The initial version of the UML2 example model in (simplified) XMI.},label=lst:xmimodel1]
%<uml:Package xmi:id="1" name="X">
%   <packagedElement xsi:type="uml:Class" xmi:id="2" name="A"/>
%  <packagedElement xsi:type="uml:Class" xmi:id="3" name="B"/>
%</uml:Package>
%\end{lstlisting}

\begin{lstlisting}[style=xmi,caption={The second version of the UML2 example model.},label=lst:xmimodel2]
<uml:Package xmi:id="1" name="X">
    <packagedElement xsi:type="uml:Class" xmi:id="3" name="C"/>
</uml:Package>
\end{lstlisting}

\begin{figure}[ht]
%row 1
\begin{subfigure}[t]{0.49\linewidth}
\centering
\includegraphics[width=\linewidth]{images/illustration_1}
\caption{Initial state}
\label{fig:illustration_1}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.49\linewidth}
\centering
\includegraphics[width=\linewidth]{images/illustration_2}
\caption{Time stamp 1}
\label{fig:illustration_2}
\end{subfigure}
%row 2
\begin{subfigure}[t]{0.49\linewidth}
\centering
\includegraphics[width=\linewidth]{images/illustration_3}
\caption{Time stamp 2}
\label{fig:illustration_3}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.49\linewidth}
\centering
\includegraphics[width=\linewidth]{images/illustration_4}
\caption{Time stamp 3}
\label{fig:illustration_4}
\end{subfigure}
%row 3
\begin{subfigure}[t]{0.49\linewidth}
\centering
\includegraphics[width=\linewidth]{images/illustration_5}
\caption{Time stamp 4}
\label{fig:illustration_5}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.49\linewidth}
\centering
\includegraphics[width=\linewidth]{images/illustration_6}
\caption{Time stamp 5}
\label{fig:illustration_6}
\end{subfigure}
%row 4
\begin{subfigure}[t]{0.49\linewidth}
\centering
\includegraphics[width=\linewidth]{images/illustration_7}
\caption{Time stamp 6}
\label{fig:illustration_7}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.49\linewidth}
\centering
\includegraphics[width=\linewidth]{images/illustration_8}
\caption{Time stamp 7}
\label{fig:illustration_8}
\end{subfigure}

\caption{The states of the example model after certain changes and their corresponding lines in Listing \ref{lst:cbpmodel}.}
\label{fig:illustration_cbp}
\end{figure}

%In change-based model persistence, instead of saving the state of the model, all the changes made to it are saved instead. Change events are collected in memory during model editing and are appended into a change-based log file when the model is saved. The changes made to the example model in both sessions can be seen in a text-based (for demonstration purposes), change-based format presented in List. \ref{lst:cbpmodel}. To load a model saved in a change-based representation, its persisted change events have to be replayed -- reenacting the construction of the model from the beginning.

\begin{lstlisting}[style=eol,caption={The text change-based persistence of producing state-based model in List. \ref{lst:xmimodel2}. Its visual illustration is in Fig. \ref{fig:illustration_cbp}.},label=lst:cbpmodel]
session 1
create p1 of Package
set p1.name to "X"  
create c1 of Class
set c1.name to "A"
create c2 of Class
set c2.name to "B"
add c1 to p1.packagedElement   
add c2 to p1.packagedElement
session 2
set c2.name to "C"
remove c1 from p1.children   
delete c1
\end{lstlisting}

To load a SBP model, only the elements that are in the final state need to be instantiated. To load a CBP model, all the events that lead to the final state must be replayed. Loading times for SBP models are proportional to the size of the model. Loading times for CBP models are proportional to the number of events. As a result, loading times of CBP models will always increase over time and are considerably longer than for SBP\,\cite{yohannis2018towards,mens2002state}. 

To store a SBP model, all the elements that exist in the final state must be persisted. To save a CBP only the change events in the last session need to be persisted. Storing times of SBP models are proportional to the size of the model. Storing times of CBP models are proportional to the number of events in a session. As a result, storing times of CBP models can be considerably shorter than for SBP models\,\cite{yohannis2018towards}. %"Storing of CBP models also requires more space as events just keep adding up. " comes up in more detail in next para, so deleted here.

Comparing and finding the differences between two versions of a state-based model is expensive \cite{Kolovos:2009:DMM:1564596.1564641} ($O(N^2)$ in the general case) %\,\cite{}) operation and beyond 
which affects the efficiency of change visualisation and comprehension, and has a substantial impact on downstream activities such as incremental model transformation \cite{DBLP:conf/ecmdafa/OgunyomiRK15} and validation.

By contrast, in change-based persistence, changes are first-class entities in the persisted model file and as such, model comparison and differencing is relatively inexpensive (Section \ref{sec:evaluation}). The main downsides of change-based persistence are ever-growing model file sizes \cite{DBLP:journals/entcs/RobbesL07,DBLP:conf/edoc/KoegelHLHD10} and ever-increasing loading times \cite{mens2002state}. Loading times can be reduced by around 50\% by processing the change log, detecting, memorising and subsequently ignoring change events that have no impact to the final state of the model, but are still substantially longer than loading times for state-based approaches \cite{yohannis2018towards}. 

Table \ref{table:persistence_comparsion} summarises the benefits (+) and drawbacks (-) of change and state-based model persistence.

% On the other hand, state-based model persistence is growing on its capabilities to process large-scale models by harnessing the power of big data backend. Morsa \cite{DBLP:conf/models/Espinazo-PaganCM11} and NeoEMF \cite{daniel2016neoemf} has been able to load and query models with more than a million elements since they are able to handle model's elements partially without having to load all the elements into memory when using the standard XMI persistence. However, using these backends hindered the models to be versioned on common version control systems (e.g. Git, SVN), which is crucial for collaborative development.

\begin{table} [ht]
\centering
\caption{Comparison of model persistence approaches.}
\label{table:persistence_comparsion}
\begin{tabular}{ c c c c }
\hline 
\textbf{Dimensions} & \textbf{Change-based} & \textbf{State-based} \\
\hline 
Load Time & $-$ & $+$ \\
Save Time & $+$ & $-$ \\
Comparison Time & $+$ & $-$ \\
Storage Space & $-$ & $+$ \\
\hline 
\end{tabular}
\end{table}

% A new approach is required to combine the benefits (+) of both approaches (fast loading and comparison) with acceptable trade-off. Thus, we proposed a hybrid model persistence -- an approach that uses change and state-based persistence side-by-side to persist models. One notable drawback for this persistence is it requires more storage space since models are saved into two types of persistence. 

\section{Hybrid Model Persistence}
\label{sec:hybrid_model_persistence}
To achieve the best of both worlds we introduce a hybrid model persistence approach which combines change-based and state-based model persistence, to work together side-by-side. An overview of the proposed approach is illustrated in Fig. \ref{fig:hybrid_persistence}.

\begin{figure}[ht]
\includegraphics[width=\linewidth]{images/hybrid_persistence}
\caption{The mechanism of hybrid model persistence.}
\label{fig:hybrid_persistence}
\end{figure}

In the proposed approach a \textit{hybrid} model is stored in two representations at the same time: a change-based (e.g. using CBP) and a state-based representation (e.g. using XMI or a database-backed approach such as NeoEMF). The change-based representation is the source of truth.  The state-based representation can be fully derived from the change-based representation.

\paragraph{Loading a hybrid model} Models are loaded into in-memory object graphs that clients (e.g. editors, transformations) can then interact with\footnote{Depending on the state persistence mechanism, the object graph may be loaded in its entirety at startup (e.g. XMI) or  loaded progressively, in a lazy manner (e.g. NeoEMF/CDO)}. In the proposed hybrid approach, if the state-based counterpart already exists, the in-memory object graph is populated from it; otherwise it is populated by replaying the complete editing history recorded in the change-based representation.

\paragraph{Changing a hybrid model} When an element in a loaded model is created, modified or deleted, the change is applied to the in-memory object graph and is also recorded in an in-memory list of changes (\textit{Editing session changes} in Fig 2). We use the term \emph{editing session} for the period between loading a model and saving back to disk. 

\paragraph{Saving a hybrid model} The current version of the in-memory object graph is stored in the preferred state-based representation.  The list of changes recorded in the current editing session (with optional processing, as described above) is appended to the change-based representation.

\paragraph{Versioning a hybrid model} Since the state-based representation is fully derived from the change-based representation, if a model needs to be versioned (e.g. in a Git repository), only the change-based representation needs to be stored. The first time it is loaded after being checked out/cloned, the state-based representation is computed and persisted locally and is used in subsequent model loading steps.

\paragraph{Comparing hybrid models} To compare two hybrid models, their change-based representations are used: this is much more efficient than state-based comparison as demonstrated in Section \ref{sec:change_detection}.

% When a model is modified by a client (e.g. editor, transformation program), the changes are recorded into both representations. The former persists all the changes to keep the model's history, while the latter is used to record the last state of the model produced by the changes. Changes persisted into the change-based representation are fully derived from the changes happened on the state-based representation. Since the change-based representation is text-based, it can be stored in a version control repository. In terms of querying (including loading), the model is directly queried from the state-based representation. Thus, replaying all the changes from its change-based representation to get the last state of the model -- which is time consuming -- can be avoided. This hybrid model persistence's mechanism is presented in Fig. \ref{fig:hybrid_persistence}.

\section{Implementation}
\label{sec:implementation}

We have implemented the proposed hybrid model persistence approach in a prototype on top of the Eclipse Modeling Framework (EMF) \cite{steinberg2008emf}. The prototype makes use of an existing implementation of change-based model persistence, the Epsilon CBP \cite{DBLP:conf/models/YohannisKP17}, augmented with two state-based persistence implementations: NeoEMF \cite{daniel2016neoemf} and XMI \cite{omg2018xmi}.

XMI has been selected as a standard state-based model persistence format (natively supported by EMF), and NeoEMF as a best-of-breed representative of database-backed state-based model persistence frameworks. The core components of the prototype are presented in Fig. \ref{fig:class_diagram}. 

\begin{figure}[ht]
\includegraphics[width=\linewidth]{images/class_diagram}
\caption{Class diagram showing the core components of the hybrid model persistence implementation.}
\label{fig:class_diagram}
\end{figure}

The Epsilon CBP provides a $ChangeEventAdapter$ class \cite{DBLP:conf/models/YohannisKP17} that extends from Ecore's $EContentAdapter$ adapter class \cite{eclipse2018eContentAdapter}. This class collects changes made to the in-memory object graph of an EMF model in the form of a list of events ($changeEvents$). Based on this class, we derived an adapter class, $ChangeHybridEventAdapter$, for the hybrid model persistence implementation. It is an abstract class so that it can be further derived to create different implementations of adapter classes for different types of state-based persistence. The $ChangeHybridNeoEMFEventAdapater$ is the adapter class for NeoEMF, and the $ChangeHybridXMIEventAdapater$ for XMI. These classes override  $notifyChanged(Notification)$ in the $ChangeEventAdapter$ class, to handle events that are specific to NeoEMF and XMI, respectively.

We also created a resource class for hybrid persistence, $HybridResource$ (a resource class is a class dedicated to interact with a persistence, e.g. save, load, get contents), derived from the Ecore's $ResourceImpl$ \cite{eclipse2018resourceImpl}. The class is again abstract so that it can be realised in different resource implementation classes for different state-based persistence. The $HybridResource$ class contains the $stateBasedResource$ field which is used to refer to a state-based persistence that is being used, and the $cbpOutputStream$ field that refers to an $OutputStream$ (e.g. file, in-memory) as the representation of the change-based persistence for saving changes. $HybridResource$ has an association with $HybridChangeEventAdapater$, so that the former can access the events collected by the latter, and the latter can also use facilities provided by the former (e.g. getting an element identity in the resource; saving changes to a change-based model representation).

The resource implementation classes for NeoEMF and XMI are $HybridNeoEMFResourceImpl$ and $HybridXMIResource$$Impl$, respectively.  $HybridNeoEMFResourceImpl$ also implements the NeoEMF's $PersistenceResource$ interface \cite{atlanmod2018persistentResource} so that specific NeoEMF's methods can used (e.g. $close$(), to close a connection with a backend database). The complete implementation is available under [Hidden for Blind Review]. %\url{https://github.com/epsilonlabs/emf-cbp}.

\subsection{Known Limitations}


Our prototype supports all the core constructs of Ecore, including classes, inheritance, single or multi-valued attributes and references, datatypes and containment. 
%F: why is this a limitation?
It also supports session-based changes to models that are atomic editor events, such as creating and deleting an object, setting and unsetting a feature. %You already defined a session, and the fact that changes are recorded on a session by session basis earlier.
%F: why is this a limitation?

With regard to notable limitations, the hybrid model persistence can only support single-file models: fragmented across multiple files and cross-model references models persisted in more than one file or backend. Secondly, an assumption is made that the two underpinning representations (change-based and state-based) are always consistent with each other i.e. that they are always modified as an indivisible unit.

\section{Evaluation}
\label{sec:evaluation}

In this section, we compare hybrid model persistence (Epsilon CBP with each of NeoEMF and XMI) vs. state-based persistence (NeoEMF or XMI only) on loading, saving, and storage space usage.
%\footnote{The prototype, tests, and data used in the evaluation are available under \url{https://github.com/epsilonlabs/emf-cbp} and \url{https://goo.gl/1zUBQC}.}
%footnote moved from next subsection because it is more relevant here
and demonstrate that hybrid model persistence offers the best of both worlds: fast model loading and saving, and efficient change detection. 

\subsection{Evaluation Method}
\label{sec:evaluation_method}
%"We developed the prototype of the proposed hybrid model persistence approach. " removed as it is obvious, later and in the footnote now above, that this is what you are reporting on.

The evaluation was performed on Intel\textsuperscript{\textregistered} Core\textsuperscript{TM} i7-6500U CPU@2.50GHz 2.59GHz, 12GB RAM, and the Java\textsuperscript{TM} SE Runtime Environment (build 1.8.0\textunderscore162-b12).

For the evaluation, we used models reverse-engineered from the Java source code of a real-world open-source project (Epsilon \cite{eclipse2017epsilon,eclipse2018epsilongit}). For state-based representation of the models, we used the MoDisco tool \cite{DBLP:journals/infsof/BruneliereCDM14} to generate XMI-based UML2 \cite{eclipse2017uml2} models that reflect the classes, fields, and operation signatures of the source code of the project and then imported the generated models into NeoEMF.  We also derived UML2 models for BPMN2 \cite{eclipse2017bpmn2} and MoDiscoXML models (models that conforms to the generic XML metamodel as provided by MoDisco) \cite{eclipse2018modiscoxml} from the Wikipedia article on the United States \cite{wikipedia2018us}.  % The source for this paragraph is not in git, so I have typed it in, with simplifications!  You need to add back in the citations!

Reverse-engineering a state-based representation of a model is trivial; the change-based representing is more challenging. Here, a change-based representation was derived from the diffs identified from the subsequent versions of the Java source code committed on its Git repository. The change-based representation was derived by comparing an initially-empty running model to the generated models sequentially, ordered by their versions. All identified differences were then reconciled by performing a one-way merge to the running model. All changes made to the running model during the merging process were captured and persisted into a CBP file. The comparison and merging were performed using EMF Compare \cite{eclipse2017compare}. This procedure follows the procedure performed in \cite{yohannis2018towards}.  %This sentence is moved from earlier, but is not in the repository text: again you need to re-add the citation.

Using these models, we evaluate the performance of our hybrid persistence prototype against XMI and NeoEMF in terms of time and memory footprint for loading, saving, and comparison/diffing of subsequent model versions using EMF Compare was used the baseline for the state-based comparison. %For the latter, we measured the delta of memory used before and after loading and saving completes. We also measured the impact of using the hybrid approach on the execution time of a model comparison, specifically for identifying differences between a model and its preceding version. The hybrid approach was compared to model-to-model comparison using EMF Compare on their execution time.

We repeated our experiments 22 times for each dimension measured. Since the data was not normally distributed and we wanted to calculate the significance of differences of mean ranks, we used the Mann-Whitney-Wilcoxon nonparametric test \cite{doi:10.1002/9780470479216.corpsy0524}. We used a significance level of 5\%.

. % If t-test' $p$-$value$ $<$ 0.05, we rejected the null hypothesis -- the $means$ of the compared persistence types are equal ($H_0$) -- and accepted the alternative hypothesis -- the $means$ of the compared persistence types are not equal ($H_1$). 

%\textbf{F: not convinced that the data you have is suitable for a t-test (which has many many required data characteristics) but this is not the right place to change.  Think about a non-parametric statistic to compare mean in the thesis... also check that means and medians are similar (i.e. the data is not skewed); if they are not similar you MUST use a comparison of medians (e.g. the A test).  I've cursorily checked that your results are not going to be way out because you used a silly statistic! }

\subsection{Loading Time and Memory Footprint}
\label{sec:model_loading_time}
In this section, we present the results of our evaluation on the time and memory footprint required for the hybrid model persistence to load a model. In the following plots we use the XMI and NEO labels for out-of-the-box XMI and NeoEMF and the H-XMI and H-NEO labels for our hybrid persistence prototypes based on XMI and NeoEMF.

\subsubsection{Epsilon Project}
\label{sec:model_loading_time_epsilon}

\begin{figure}[ht]
\includegraphics[width=\linewidth]{images/load_time_epsilon}
\caption{Hybrid vs. state-based model persistence on model loading time for the Epsilon project.}
\label{fig:load_time_epsilon}
\end{figure}

\begin{figure}[ht]
\includegraphics[width=\linewidth]{images/load_memory_epsilon}
\caption{loading memory footprint}
\caption{Hybrid vs. state-based model persistence on the memory footprint of loading a model for the Epsilon project.}
\label{fig:load_memory_epsilon}
\end{figure}

The model used for testing is the UML2 model of the Epsilon project that consists of 88,020 elements. The model is derived from the committed version number 940 from its Git repository \cite{eclipse2018epsilongit}. 

The results show that the average loading time using Hybrid NeoEMF ($mean$ = 0.292, $sd$ = 0.061 seconds) is slightly slower than NeoEMF ($mean$ = 0.279, $sd$ = 0.023 seconds) but insignificant ($W$ = 258, $p$-value = 0.72). For Hybrid XMI, the slowdown is significant ($W$ = 0, $p$-value $<$ 0.05), hybrid XMI taking  ($mean$ = 0.873, $sd$ = 0.038 seconds), compared to XMI ($mean$ = 0.616, $sd$ = 0.015 seconds).  %F: took out the average slowdown, as it is  meaningless unless expressed relative to the time taken... 0.3 sec on a mean of 0.6 secions is a 50% slowdown! 

The memory footprint after loading the model for Hybrid NeoEMF ($mean$ = 39, $sd$ = 0.9 MBs) is larger than for NeoEMF ($W$ = 0, $sd$ = 1.1 MBs); the result is statistically significant ($W$ = 0, $p$-value $<$ 0.05). A similarly significant increase of the memory footprint ($W$ = 0, $p$-value $<$ 0.05) is found when comparing Hybrid XMI ($mean$ = 12.8, $sd$ = 0.0 MBs) and XMI ($mean$ = 5.2, $sd$ = 0.0 MBs) when loading the model.  

\begin{figure}[ht]
\includegraphics[width=\linewidth]{images/load_time_bpmn2}
\caption{Hybrid vs. state-based model persistence on model loading time for the BPMN2 project.}
\label{fig:load_time_bpmn2}
\end{figure}

\begin{figure}[ht]
\includegraphics[width=\linewidth]{images/load_memory_bpmn2}
\caption{loading memory footprint}
\caption{Hybrid vs. state-based model persistence on the memory footprint of loading a model for the BPMN2 project.}
\label{fig:load_memory_bpmn2}
\end{figure}


\subsubsection{BPMN2 Project}
\label{sec:model_loading_time_bpmn2}

The UML2 model of the BPMN2 project consists of 62,062 elements. The model is derived from the committed version number 192 from its Git repository \cite{eclipse2018bpmn2git}. 

For this model, the average loading time for Hybrid NeoEMF ($mean$ = 0.308, $sd$ = 0.071 seconds) is slightly slower than for NeoEMF ($mean$ = 0.286, $sd$ = 0.025 seconds) but the result is not  significant ($W$ = 230, $p$-value = 0.79). The slowdown is statistically significant ($W$ = 37, $p$-value $<$ 0.05) for Hybrid XMI ($mean$ = 0.212, $sd$ = 0.016 seconds) vs.compared to XMI ($mean$ = 0.179, $sd$ = 0.016 seconds).  %F: as above!!

For the memory footprint after loading the model, Hybrid NeoEMF ($mean$ = 40.78, $sd$ = 1.29 MBs) uses more memory than NeoEMF ($mean$ = 27.20, $sd$ = 1.05 MBs); the result is statistically significant ($W$ = 0, $p$-value $<$ 0.05). For the comparison between Hybrid XMI ($mean$ = 6.73374, $sd$ = 1.29305 MBs) and XMI ($mean$ = 6.73367, $sd$ = 0.00056 MBs), the increase of memory footprint is also significant ($W$ = 101, $p$-value $<$ 0.05).  

\subsubsection{Wikipedia Article}
\label{sec:model_loading_time_wikipedia}

\begin{figure}[ht]
\includegraphics[width=\linewidth]{images/load_time_wikipedia}
\caption{Hybrid vs. state-based model persistence on model loading time for the Wikipedia article.}
\label{fig:load_time_wikipedia}
\end{figure}

\begin{figure}[ht]
\includegraphics[width=\linewidth]{images/load_memory_wikipedia}
\caption{loading memory footprint}
\caption{Hybrid vs. state-based model persistence on the memory footprint of loading a model for the Wikipedia article.}
\label{fig:load_memory_wikipedia}
\end{figure}

The ModiscoXML model of the Wikipedia's United States article consists of 13,122 elements. The model is derived from the version number 10,187 (id 45118452) of its online page \cite{wikipedia2018us}. 

For this model, the average loading time of Hybrid NeoEMF ($mean$ = 0.287, $sd$ = 0.028 seconds) is slightly slower than NeoEMF ($mean$ = 0.275, $sd$ = 0.001 seconds) and significant ($W$ = 129, $p$-value $<$ 0.05), but the slowdown is only at the level of 4.36\%. The slowdown on Hybrid XMI ($mean$ = 0.045, $sd$ = 0.001 seconds) compared to XMI ($mean$ = 0.040, $sd$ = 0.001 seconds) is not significant ($W$ = 0, $p$-value $<$ 0.05).  

For the memory footprint after loading the model, Hybrid NeoEMF ($mean$ = 35.91, $sd$ = 1.03 MBs) uses more memory than NeoEMF ($mean$ = 27.25, $sd$ = 0.54 MBs); the difference is not statistically significant ($W$ = 0, $df$ = $p$-value $<$ 0.05). A insignificant difference ($W$ = 0, $p$-value $<$ 0.05)  is also found when comparing the memory footprint for Hybrid XMI ($mean$ = 8.4079, $sd$ = 0.0008 MBs) vs. XMI ($mean$ = 8.0933, $sd$ = 0.0009 MBs).  

\subsection{Model Saving Time and Memory Footprint}
\label{sec:model_saving_time}

In this section, we evaluated the time taken to save a changed model using hybrid model persistence, and the change in memory footprint.  The models are the same as those used in Section \ref{sec:model_loading_time}.

\subsubsection{Epsilon Project}
\label{sec:model_saving_time_epsilon}

\begin{figure}[ht]
\includegraphics[width=\linewidth]{images/save_time_epsilon}
\caption{Hybrid vs. state-based model persistence on model saving time.}
\label{fig:save_time_epsilon}
\end{figure}

\begin{figure}[ht]
\includegraphics[width=\linewidth]{images/save_memory_epsilon}
\caption{Hybrid vs. state-based model persistence on the memory footprint of saving a model.}
\label{fig:save_memory_epsilon}
\end{figure}

For UML2 model version 940 of the Epsilon project, the average Hybrid NeoEMF saving time for each change ($mean$ = 0.0892, $sd$ = 0.0421 seconds) is slightly slower than for NeoEMF ($mean$ = 0.0829, $sd$ = 0.0494 seconds) and the difference is not statistically significant ($W$ = 216, $p$-value = 0.55). The slowdown is statistically significant ($W$ = 78, $p$-value $<$ 0.05) for Hybrid XMI ($mean$ = 0.411, $sd$ = 0.023 seconds) vs. XMI ($mean$ = 0.397, $sd$ = 0.015 seconds).  

The memory footprint after saving a change to the model in Hybrid NeoEMF ($mean$ = 2.64, $sd$ = 1.29 MBs) is larger than for NeoEMF ($mean$ = 2.61, $sd$ = 0.78 MBs) but is not statistically significant ($W$ = 283, $p$-value $=$ 0.34). The Hybrid XMI ($mean$ = 1.56355, $sd$ = 0.0005 MBs) also uses more memory than XMI ($mean$ = 1.56326, $sd$ = 0.0018 MBs) when loading the model and also significant ($W$ = 408, $p$-value $<$ 0.05).  

\subsubsection{BPMN2 Project}
\label{sec:model_saving_time_bpmn2}

\begin{figure}[ht]
\includegraphics[width=\linewidth]{images/save_time_bpmn2}
\caption{Hybrid vs. state-based model persistence on model saving time for the BPMN2 project.}
\label{fig:save_time_bpmn2}
\end{figure}

\begin{figure}[ht]
\includegraphics[width=\linewidth]{images/save_memory_bpmn2}
\caption{Hybrid vs. state-based model persistence on the memory footprint of saving a model for the BPMN2 project.}
\label{fig:save_memory_bpmn2}
\end{figure}

For the UML2 model version 192 of the BPMN2 project, the average saving time for each change using Hybrid NeoEMF ($mean$ = 0.0777, $sd$ = 0.0424 seconds) is slightly slower than the for NeoEMF ($mean$ = 0.0775, $sd$ = 0.0452 seconds) but not statistically  significant ($W$ = 213, $p$-value = 0.51). The slowdown is statistically significant ($0$ = 0, $p$-value $<$ 0.05) for Hybrid XMI ($mean$ = 0.33, $sd$ = 0.007 seconds) vs. XMI ($mean$ = 0.28, $sd$ = 0.008 seconds).  

The memory footprint after saving a change made to the model in Hybrid NeoEMF ($mean$ = 1.86, $sd$ = 3.86 MBs) is larger than for NeoEMF ($mean$ = 1.52, $sd$ = 0.77 MBs) but not significant ($W$ = 308, $p$-value $<$ 0.12). Hybrid XMI ($mean$ = 0.8378, $sd$ = 0.00361 MBs) also uses more memory than XMI ($mean$ = 0.8375, $sd$ = 0.00362 MBs) when loading the model and at the significant level ($W$ = 58, $p$-value $<$ 0.05).  

\subsubsection{Wikipedia Article}
\label{sec:model_saving_time_wikipedia}

\begin{figure}[ht]
\includegraphics[width=\linewidth]{images/save_time_wikipedia}
\caption{Hybrid vs. state-based model persistence on model saving time for the Wikipedia article.}
\label{fig:save_time_wikipedia}
\end{figure}

\begin{figure}[ht]
\includegraphics[width=\linewidth]{images/save_memory_wikipedia}
\caption{Hybrid vs. state-based model persistence on the memory footprint of saving a model for the Wikipedia article.}
\label{fig:save_memory_wikipedia}
\end{figure}

The MoDiscoXML model version 10,187 of the Wikipedia's United States article has an average saving time for each change in Hybrid NeoEMF ($mean$ = 0.135, $sd$ = 0.048 seconds) that is slightly slower than for NeoEMF ($mean$ = 0.120, $sd$ = 0.024 seconds) but the difference is not statistically significant ($W$ = 218, $p$-value = 0.59). The slowdown on Hybrid XMI ($mean$ = 0.024, $sd$ = 0.048 seconds) vs. XMI ($mean$ = 0.020, $sd$ = 0.002 seconds) is significant ($W$ = 42, $p$-value $<$ 0.05).

The memory footprint after saving a change made to the model using Hybrid NeoEMF ($mean$ = 1.32, $sd$ = 1.51 MBs) is larger than for NeoEMF ($mean$ = 0.97, $sd$ = 0.76 MBs) but statistically insignificant ($W$ = 189, $p$-value $=$ 0.22). Hybrid XMI ($mean$ = 0.0010, $sd$ = 0.00044 MBs) also uses more memory than XMI ($mean$ = 0.0005, $sd$ = 0.00001 MBs); the difference is significant ($W$ = 0, $p$-value $<$ 0.05).  

\subsection{Storage Space Usage}
\label{sec:storage_space_usage}

To further evaluate storage space usage of the hybrid model persistence, we used the the CBPs generated from the Epsilon project, the BPMN2 project, and the Wikipedia United States (US) article. We again generated the committed versions of the BPMN2 project as UML2 models and the versions of the Wikipedia article as MoDiscoXML models. For the Epsilon project, we have successfully generated CBPs from version 1 up to version 940. For the BPMN2 project and Wikipedia article, we have successfully generated their CBPs up to version number 192 and 10,187 respectively. The details (element count, event count, space size, and average space size per element or event) of their models when persisted in XMI, NeoEMF, and CBP are shown, respectively, in Tables \ref{table:space_usage_epsilon}, \ref{table:space_usage_bpmn2}, and \ref{table:space_usage_wikipedia}. 

The last column of each table derives an average space usage per element (for the SBPs) or event (for the CBP).  We can estimate the storage space usage for a hybrid model persistence to be the combination of CBP and the appropriate SBP space usage.

\begin{table} [ht]
\centering
\caption{Space Usage for the Epsilon project. The CBP were generated from  version 1 to 940 of the project.}
\label{table:space_usage_epsilon}
\begin{tabular}{ p{0.1\linewidth} p{0.1\linewidth} p{0.12\linewidth} p{0.13\linewidth} p{0.26\linewidth} }
\hline 
\textbf{Type} & \textbf{Element Count} & \textbf{Event Count} & \textbf{Space Size} & \textbf{Average Space Size} \\
\hline 
XMI & 88,020 &  & 9.44 MBs & 112 bytes / element  \\
NeoEMF & 88,020 &  & 188 MBs & 2 KBs / element \\
CBP &  & 4,307,051 & 406 MBs &  98 bytes / event \\
\hline 
\end{tabular}
\end{table}

\begin{table} [ht]
\centering
\caption{Space usage for the BPMN2 project. The CBP were generated from version 1 to 192 of the project.}
\label{table:space_usage_bpmn2}
\begin{tabular}{ p{0.1\linewidth} p{0.1\linewidth} p{0.12\linewidth} p{0.13\linewidth} p{0.26\linewidth} }
\hline 
\textbf{Type} & \textbf{Element Count} & \textbf{Event Count} & \textbf{Space Size} & \textbf{Average Space Size} \\
\hline 
XMI & 62,062 &  & 6.55 MBs & 110 bytes / element  \\
NeoEMF & 62,062 &  & 134 MBs & 2 KBs / element \\
CBP &  & 1,238,751 & 109 MBs &  92 bytes / event \\
\hline 
\end{tabular}
\end{table}

\begin{table} [ht]
\centering
\caption{Space Usage for the Wikipedia's US article. The CBP were generated from version 1 to 10,187 of the article.}
\label{table:space_usage_wikipedia}
\begin{tabular}{ p{0.1\linewidth} p{0.1\linewidth} p{0.12\linewidth} p{0.13\linewidth} p{0.26\linewidth} }
\hline 
\textbf{Type} & \textbf{Element Count} & \textbf{Event Count} & \textbf{Space Size} & \textbf{Average Space Size} \\
\hline 
XMI & 13,112 &  & 1.28 MBs & 102 bytes / element  \\
NeoEMF & 13,112 &  & 31.8 MBs & 2 KBs / element \\
CBP &  & 62,271,003 & 5.85 GBs &  98 bytes / event \\
\hline 
\end{tabular}
\end{table}

\subsection{Change Detection}
\label{sec:change_detection}
In this section, we present the the evaluation of change-based persistence as a component of the hybrid model persistence, on model change detection. In this evaluation, we used four versions of the Epsilon project UML2 model: committed versions 8, 44, 181, and 388: details are in Table \ref{table:version_description}.

\begin{table}
\centering
\caption{Description of version 8, 44, 181, and 388 of the Epsilon project's UML2 model.}
\label{table:version_description}
\begin{tabular}{ r r r r r}
\hline 
\textbf{\thead{Versions}} & \textbf{\thead{Element\\Counts}} & \textbf{\thead{Delta Elements\\(from ver. 8)}} & \textbf{\thead{Event\\Counts}} & \textbf{\thead{Delta Events\\(from ver. 8)}}  \\
\hline 
008	& 25,993 & 0	& 90,888 & 0\\
044	& 31,240 & 5,247	& 166,659 & 75,771\\
181	& 34,196 & 8,203	& 250,073 & 159,185\\
388	& 48,482 & 22,489 & 332,315 & 241,427\\
\hline 
\end{tabular}
\end{table}


As the scenario for the evaluation, we identify the elements in the older model (lower version number) that do not exist in the newer model (higher version number).  Our dataset comprises the pairs, 008 and 044, 008 and 181, and 008 and 383. %made version representation consistent with subsequent parts...

We used two methods to identify deleted elements. First, we iterated through events in the change-based representation of the pairs' hybrid-model representation (\emph{the hybrid method}). Second, we performed model-to-model comparison between the two states of the paired versions using EMF Compare and selected diffs representing deleted elements (\emph{the state-based method}). We compared both methods on the time they required to identify all the deleted elements. We performed measurement 22 times for each pair and method to calculate the time. Fig. \ref{fig:delete_detection_epsilon_average} shows the result of the comparison. 

\begin{figure}
\includegraphics[width=\linewidth]{images/delete_detection_epsilon_average}
\caption{The time required for hybrid and state-based methods on detecting older version's elements that do not exist in newer versions.}
\label{fig:delete_detection_epsilon_average}
\end{figure}

For the pair 008 and 044, the change detection is 3.47 seconds faster for the state-based method ($mean$ = 10.81 , $sd$ = 0.16 seconds) than using the hybrid method ($mean$ = 14.28, $sd$ = 0.36 seconds).  However, for the pair 008 and 181, the change detection is 44.07 seconds faster for the hybrid method ($mean$ = 28.62 , $sd$ = 0.17 seconds) than the state-based method ($mean$ = 72.69, $sd$ = 1.28 seconds). The hybrid method is again faster for the last pair, 008 and 388): hybrid method ($mean$ = 42.93, $sd$ = 0.18 seconds) is 234.84 seconds faster than the change-based method ($mean$ = 277.77, $sd$ = 4.70 seconds). Considering the increasing number of elements and events (Table \ref{table:version_description}), the change identification time of the hybrid method tends to grow linearly as the number of events increases, whereas the stated-based method tends to grow exponentially as the number of elements increases.

\subsection{Threats to Validity and Limitations}
\label{sec:threats_to_validity_and_limitations}
Since change-based model persistence is a relatively new concept, there are hardly any such models available in public repositories that we could reuse for evaluating our prototype. So far, we have only tested the hybrid model persistence approach on synthesised models which may not be representative of the characteristics of models created by people.

\section{Discussion}
\label{sec:discussion}
The evaluation results for change detection, Section \ref{sec:change_detection}, show that model change detection in hybrid model persistence is substantially faster state-based comparison. This is because elements and features that have been modified can be directly identified through the events recorded in its change-based persistence representation without the need to compare the models element-by-element. The use of state-based persistence in hybrid model persistence enables faster model loading, as shown by the result of loading time evaluation in Section \ref{sec:model_loading_time}, without having to replay all the changes persisted in its change-based persistence -- the main challenge for the change-based approach \cite{mens2002state}. 
Hybrid model persistence performs slightly slower but the differences are not statistically significant compared to loading a a state-based model. A statistically insignificant slowndown also appears on model saving, Section \ref{sec:model_saving_time}: the slowdown is because changes have to be persisted into two representations, state-based and change-based. 

The main drawback of hybrid model persistence is that it consumes more memory when loading and saving and storage space for persisting models compared to state-based representation only (Sections \ref{sec:model_loading_time}, \ref{sec:model_saving_time}, and \ref{sec:storage_space_usage}). However, considering the cost of main memory and storage, the trade-off can be acceptable in most real-world scenarios.

\section{Related Work}
\label{sec:related_work}
Change-based persistence approaches have been used widely in incremental model management engines (e.g. IncQuery \cite{DBLP:conf/ecmdafa/RathHV12}, ReactiveATL \cite{DBLP:conf/ecmdafa/OgunyomiRK15}) usually by harnessing the notification facilities provided by the underlying modelling framework (e.g. EMF). Such approaches have also been applied in other software \cite{DBLP:journals/entcs/RobbesL07}, databases \cite{DBLP:conf/sde/LippeO92}, hierarchical documents \cite{DBLP:conf/caise/IgnatN05}, model repositories and version control \cite{koegel2010emfstore}. The approach is faster for detecting changes \cite{DBLP:conf/edoc/KoegelHLHD10}, more accurate and carries semantic information (e.g. actors, objects, timestamps, and sequences involved in events) \cite{DBLP:journals/entcs/RobbesL07,DBLP:conf/sde/LippeO92,DBLP:conf/caise/IgnatN05,mens2002state}, faster and more accurate for comparison and merging \cite{DBLP:conf/sde/LippeO92,DBLP:conf/caise/IgnatN05,koegel2010emfstore}, and enable additional analytics activities \cite{DBLP:journals/entcs/RobbesL07}.

There are several non-XMI approaches to state-based model persistence, using relational or NoSQL databases. For example, EMF Teneo\,\cite{eclipse2017teneo} persists EMF models in relational databases, while Morsa \cite{DBLP:conf/models/Espinazo-PaganCM11} and NeoEMF \cite{daniel2016neoemf} persist models in document and graph databases, respectively.  None of these approaches provides built-in support for versioning and models are eventually stored in binary files/folders which are known to be a poor fit for text-oriented version control systems like Git and SVN. Connected Data Objects (CDO) \cite{eclipse2017cdo}, which provides support for database-backed model persistence, also provides collaboration facilities, but CDO adoption necessitates the use of a separate version control system (e.g. a Git repository for code and a CDO repository for models), which introduces fragmentation and administration challenges \cite{barmpis2014evaluation}. Similar challenges arise in relation to other model-specific version control systems such as EMFStore\,\cite{koegel2010emfstore}.  %prefer this to the wording in the repository version!

\section{Conclusions and Future Work}
\label{sec:conlcusions_and_future_work}
In this paper, we have proposed a hybrid model persistence approach and evaluated its impact on time and memory footprint for model loading and saving, storage space usage, and detecting changes of versions of the same model. Based on the evaluation results, the hybrid model persistence provides  benefits on model loading time and change detection with acceptable trade-off on memory footprint and storage space usage.

In the future, we plan to evaluate  hybrid model persistence on even larger models, and perform experiments where software modellers are asked to construct change-based models. We also plan to develop a solution for efficient merging of change-based and hybrid models.  

% An example of a floating figure using the graphicx package.
% Note that \label must occur AFTER (or within) \caption.
% For figures, \caption should occur after the \includegraphics.
% Note that IEEEtran v1.7 and later has special internal code that
% is designed to preserve the operation of \label within \caption
% even when the captionsoff option is in effect. However, because
% of issues like this, it may be the safest practice to put all your
% \label just after \caption rather than within \caption{}.
%
% Reminder: the "draftcls" or "draftclsnofoot", not "draft", class
% option should be used if it is desired that the figures are to be
% displayed while in draft mode.
%
%\begin{figure}[!t]
%\centering
%\includegraphics[width=2.5in]{myfigure}
% where an .eps filename suffix will be assumed under latex, 
% and a .pdf suffix will be assumed for pdflatex; or what has been declared
% via \DeclareGraphicsExtensions.
%\caption{Simulation results for the network.}
%\label{fig_sim}
%\end{figure}

% Note that the IEEE typically puts floats only at the top, even when this
% results in a large percentage of a column being occupied by floats.


% An example of a double column floating figure using two subfigures.
% (The subfig.sty package must be loaded for this to work.)
% The subfigure \label commands are set within each subfloat command,
% and the \label for the overall figure must come after \caption.
% \hfil is used as a separator to get equal spacing.
% Watch out that the combined width of all the subfigures on a 
% line do not exceed the text width or a line break will occur.
%
%\begin{figure\\}[!t]
%\centering
%\subfloat[Case I]{\includegraphics[width=2.5in]{box}%
%\label{fig_first_case}}
%\hfil
%\subfloat[Case II]{\includegraphics[width=2.5in]{box}%
%\label{fig_second_case}}
%\caption{Simulation results for the network.}
%\label{fig_sim}
%\end{figure\\}
%
% Note that often IEEE papers with subfigures do not employ subfigure
% captions (using the optional argument to \subfloat[]), but instead will
% reference/describe all of them (a), (b), etc., within the main caption.
% Be aware that for subfig.sty to generate the (a), (b), etc., subfigure
% labels, the optional argument to \subfloat must be present. If a
% subcaption is not desired, just leave its contents blank,
% e.g., \subfloat[].


% An example of a floating table. Note that, for IEEE style tables, the
% \caption command should come BEFORE the table and, given that table
% captions serve much like titles, are usually capitalized except for words
% such as a, an, and, as, at, but, by, for, in, nor, of, on, or, the, to
% and up, which are usually not capitalized unless they are the first or
% last word of the caption. Table text will default to \footnotesize as
% the IEEE normally uses this smaller font for tables.
% The \label must come after \caption as always.
%
%\begin{table}[!t]
%% increase table row spacing, adjust to taste
%\renewcommand{\arraystretch}{1.3}
% if using array.sty, it might be a good idea to tweak the value of
% \extrarowheight as needed to properly center the text within the cells
%\caption{An Example of a Table}
%\label{table_example}
%\centering
%% Some packages, such as MDW tools, offer better commands for making tables
%% than the plain LaTeX2e tabular which is used here.
%\begin{tabular}{|c||c|}
%\hline
%One & Two\\
%\hline
%Three & Four\\
%\hline
%\end{tabular}
%\end{table}


% Note that the IEEE does not put floats in the very first column
% - or typically anywhere on the first page for that matter. Also,
% in-text middle ("here") positioning is typically not used, but it
% is allowed and encouraged for Computer Society conferences (but
% not Computer Society journals). Most IEEE journals/conferences use
% top floats exclusively. 
% Note that, LaTeX2e, unlike IEEE journals/conferences, places
% footnotes above bottom floats. This can be corrected via the
% \fnbelowfloat command of the stfloats package.



% conference papers do not normally have an appendix


% use section\\ for acknowledgment
\section*{Acknowledgment}
[Hidden for Blind Review]
%This research is part of a doctoral programme funded by \emph{Lembaga Pengelola Dana Pendidikan Indonesia} (Indonesia Endowment Fund for Education).

% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{30}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://mirror.ctan.org/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
%\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)
%\begin{thebibliography}{1}
%
%\bibitem{IEEEhowto:kopka}
%H.~Kopka and P.~W. Daly, \emph{A Guide to \LaTeX}, 3rd~ed.\hskip 1em plus
%  0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.
%
%\end{thebibliography}

\bibliographystyle{IEEEtran}
\bibliography{references}



% that's all folks
\end{document}
